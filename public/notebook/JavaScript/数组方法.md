# 基本的数组方法

```js
const numbers = [1, 2, 3, 5]
```



### 更改原数组：

### numbers.toString()

> 所有 js 对象都有的方法

不能指定分隔符

```shell
'1,2,3,4,5'
```



### numbers.join()

```shell
numbers.join('-');
'1-2-3-4-5'
```



### numbers.pop()

弹出最后位元素，对原数组操作，返回弹出值

```shell
numbers.pop(); // 弹出最后位
5
```



### numbers.push()

末尾追加一个元素，返回当前数组元素个数

```shell
numbers.push(6);
6 // numbers: [1, 2, 3, 5, 6]

numbers.push(9, 10);
8 // numbers: [1, 2, 3, 5, 6, 9, 10]

```



### numbers.shift()

删除首个元素，返回删除值



numbers.unshift()

首位追加一个元素，返回当前数组个数



### numbers.splice()

删除和拼接（个人理解为添加），返回被删除的元素所组成的数组

> numbers.splice(开始位置, 需删除元素的个数, 拼接的内容);

```js
numbers.splice(2, 0, 22, 222);
// []
```



### 不更改原数组：

### numbers.concat(newArry)

```js
const newArry1 = ['a', 'b']
const newArry2 = ['x', 'y']
newArry3 = numbers.concat(newArry1, newArry2);
// [1, 2, 3, 4, 5, 'a', 'b', 'x', 'y']
```



### numbers.slice()

> numbers.slice(开始位置, 结束位置); // 结束位置不指定则为开始位置后的所有元素





# arr.sort()

```js
arr = ['a', 'b', 'c', 'd', 'e']
```



### arr.sort()

顺序排序，会更改原数组

> 默认数字排序也只按第一个（最高位）排序，所以可以传达一个函数



#### 比较函数格式

```js
function compare(a, b) {
  if (a < b ) {           // 按某种排序标准进行比较, a 小于 b
    return -1;
  }
  if (a > b ) {
    return 1;
  }
  // a must be equal to b
  return 0;
}
```



#### arr.sort((a, b)=>{a-b})

顺序排序

> sort() 本身是顺序排序，所以把比较函数返回负值后，sort 把返回负值的 a 放前面（a比b小时）



#### arr.sort((a, b)=>{b-a})

逆序排序



### arr.reverse()

逆序排序

> 数字排序也只按第一个（最高位）排序



### Math.max.apply(null, arr)



### Math.min.apply(null, arr)





# 数组迭代

```js
const arr = [1, 2, 3];
```



### arr.forEach()

> arr.forEach((元素值, 元素索引, 数组本身)=>{});

```js
arr.forEach((element, index, arry)=>{
	console.log(element, index);
});
```



### arr.map()

创建一个新数组

> arr.forEach((元素值, 元素索引, 数组本身)=>{});

```js
arr2 = arr.map((element, index, arry)=>{
	return element * 2;
});
```



### arr.filter()

创建一个新数组，过滤

```js
arr2 = arr.filter((element, index, arry)=>{
	return element > 3;
});
```



### arr.reduce()

对数组中的每个元素按序执行一个由您提供的 **reducer** 函数，每一次运行 **reducer** 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值

> arr.reduce((previousValue, currentValue, currentIndex, arry)=>{}, initialValue);

```js
const array1 = [1, 2, 3, 4];

// 0 + 1 + 2 + 3 + 4
const initialValue = 0;
const sumWithInitial = array1.reduce(
  (previousValue, currentValue) => previousValue + currentValue,
  initialValue
);

console.log(sumWithInitial);
// expected output: 10
```



### arr.reduceRight()

从由到左执行



### arr.every()

测试一个数组内的所有元素是否都能通过某个指定函数的测试，返回一个布尔值

> arr.every((element, index, arry) => {});



### arr.some()

测试数组内是否有至少一个通过指定的函数测试，返回布尔值

> arr.some((element, index, arry) => {})



### arr.indexOf()

返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1

> arr.indexOf(searchElemt[, fromIndex]);



### arr.lastIndexOf()

从数组的后面向前查找，从 fromIndex  处开始

> arr.lastIndexOf(searchElement[, fromIndex])



### arr.find()

返回数组中满足提供的测试函数的第一个元素的值，否则返回 undefined

> value = arr.find(callback[, thisArg]);

> thisArg 执行回调时用作 this 的对象

```js
value = arr.find((element, index, array) => element > 5);
```



### arr.findIndex()

返回数组中满足提供的测试函数的第一个元素的**索引**，若没有找到对应元素则返回-1

> arr.findIndex(callback[, thisArg])