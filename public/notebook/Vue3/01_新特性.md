## setup(props, context)

context

> context.attrs：组件外部传过来的属性，且自身没有在 props 中声明
>
> context.emit：自定义事件
>
> context.slots：插槽



```vue
<script>
// import {h} from 'vue'
import { ref } from 'vue'

export default {
  name: "App",
  components: {},
  setup() {
    let name1 = ref('yu');
    let name2 = ref('jiang');

    function myname() {
      alert(`名字是${name1.value + name2.value}`);
    }

	// 需要返回值
    return {
      name1,
      name2,
      myname,
    };

    // 渲染函数, template 内的内容将清空
    // return ()=>{ return h('h1', '江') }
  },
};
</script>
```



## ref

> vue2 是给标签打标识

```vue
<template>
  <!-- 2. 直接引用 -->
  <h5>name1: {{ name1 }}</h5>
  <h5>name2: {{ name2 }}</h5>
  <div>
    {{ job.type }} -- {{ job.salary }}
  </div>
</template>
<script>
import { ref } form 'vue'
export default {
  name: "App",
  setup() {
      
    // 0. 使其变为响应式, 这时候为 Reflmpl 引用对象
    let name1 = ref('yu');
    let name2 = ref('jiang');
      
    // 0. job 为 Reflmpl 对象，区别于 reactive
    // Reflmpl 的 value 是 Proxy 对象
    let job = ref({
        type: '前端工程师',
        salary: '30k'
    })
    
    console.log(job);
      
    function myname() {
      // 1. 取值是取其 value, template 中则直接使用对象名即可
      alert(`名字是${name1.value + name2.value}`);
        
      // 1. value 为 Proxy 对象，先访问 value
      alert(job.value.type, job.value.salary)
    }

    return {
      name1,
      name2,
      myname
    };
  },
};
</script>
```



## reactive

> 使其响应式， 只用于 对象 类型，
>
> 区别于 vue2 的不能监控

```js
import { reactive } from 'vue'
```

```js
// 为Proxy 对象，深层监控
let job = reactive({
    type: '前端工程师',
    salary: '30k'
})

// 直接访问
console.log(job.type)

hobby = reactive(['1', '2'])
hobby[0] = 1 // 依旧是响应式
```



## Proxy 与 defineProperty

> window.Proxy() 和 Object.defineProperty()

### Object.defineProperty()

> 修改可以监测到，但是删除与增加并不能监测

```js
const person = {
  a: 1,
  b: 2,
};

const p = {};
Object.defineProperty(p, "a", {
  get() {
    return person.a;
  },
  set(value) {
    console.log("修改之后在此操作");
    person.a = value;
  },
});
```



### window.Proxy()

```js
const person = {
  a: 1,
  b: 2,
};

// const p = new Proxy(person, {}) // 这里可监测到增删改查，但传入的不是空对象时，操作都需要手动操作

const p = new Proxy(person, {
  get(target, propName) {
    console.log('读取时可操作');
    return target[propName];
  },
  set(target, propName, value) {
    console.log('修改、追加 时可操作');
    target[propName] = value;
  },
  deleteProperty(target, propName) {
    console.log('删除时可操作');
    return delete target[propName];
  }
});
```



## computed



```vue
<script>
import { reactive, computed } from 'vue'

export default {
    setup() {

        let person = reactive({
            firstName: 'zhang',
            lastName: 'jiang'
        })

        // 计算属性简写，追加 fullName
        // person.fullName = computed(()=>{
        //     return person.firstName + ' ' + person.lastName;
        // })
        
        person.fullName = computed({
            get() {
                return person.firstName + ' ' + person.lastName;
            },
            set(value) {
                let temp = value.split('-');
                person.firstName = temp[0];
                person.lastName = temp[1];
            }

        })
        
        return {
            person
        }
    }
}
</script>
```



## watch

```vue
<script>
import { reactive, ref } from "@vue/reactivity";
import { watch } from "@vue/runtime-core";
export default {
  name: "App",
  components: {},
  setup() {
    let sum = ref(0);
    let msg = ref("msg");
    let job = reactive({
      a: 1,
      b: 2,
    });

    // 1. 监视 1 个 ref
    watch(
      sum,
      (newValue, oldValue) => {
        console.log(newValue, oldValue);
      },
      { immediate: true } // 第三个参数为配置项
    );

    // 2. 监听多个响应式数据
    watch([sum, msg], (newValue, oldValue) => {
      console.log(newValue, oldValue);
    });

    // 3. 监听 reactive 定义的数据，无法正确获得 oldValue
    // 默认强制开启深度监视，且 deep 配置无效
    watch(job, (value, oldValue) => {
      console.log(value, oldValue); // 这里的 oldValue 是不正确的
    });

    // 4. 监听监听 reactive 定义的数据的某一属性
    // 使用函数返回值
    // 能够获得 oldValue
    watch(()=>job.a, (newValue, oldValue) => {
      console.log(newValue, oldValue);
    });

    // 5. 监听 reactive 定义的数据的某些属性
    watch([()=>job.a, ()=>job.b], (newValue, oldValue) => {
      console.log(newValue, oldValue); // 输出也是数组
    }, {deep: true});

    // 6. deep 配置需要开启的情况
    // 监听 reactive 所定义对象中的属性，也无法正确获得 oldValue
    watch(()=>job.c, (newValue, oldValue) => {
      console.log(newValue, oldValue); // 输出也是数组
    }, {deep: true});

    return {
      sum,
      msg,
      job,
    };
  },
};
</script>
```



## watchEffect

```vue
<script>
import { ref, watchEffect } from "@vue/runtime-core";
export default {
  name: "App",
  components: {},
  setup() {
    let sum = ref(0);
      
    //  不指定监听具体的数据，自动监听出现的数据
    watchEffect(() => {
      let temp = sum.value;
      console.log("@@", temp);
    });
      
    setTimeout(() => {
      sum.value = 2;
    }, 1000);
  },
};
</script>
```



## 生命周期





## hook

本质是函数

>|- src
>
>​	|- hooks



## toRef



```vue
<script>
import { reactive, toRef } from "@vue/runtime-core";
export default {
  name: "App",
  components: {},
  setup() {
    let job = reactive({
      a: 1,
      b: 2,
    });

    return {
      a: toRef(job, "a"), // a 改变，job.a 也会改变
    };
  },
};
</script>
```



## toRefs

```vue
<script>
import { reactive, toRefs } from "@vue/runtime-core";
export default {
  name: "App",
  components: {},
  setup() {
    let job = reactive({
      a: 1,
      b: 2,
    });

    return {
      ...toRefs(job)
    };
  },
};
</script>
```



## shallowReactive 与 shallowRef

> 性能优化

```vue
<script>
import { shallowReactive, shallowRef } from "@vue/runtime-core";
export default {
  name: "App",
  components: {},
  setup() {
    let job = shallowReactive({
      a: 1,
      b: 2,
      c: {
        value: 3, // 这一层不再监视
      },
    });
      
    // shallwRef 只进行基本数据类型的响应式，不处理对象的响应式
    // job2 的value 为 对象 类型，不再是 Proxy
    let job2 = shallowRef({
      a: 1,
      b: 2,
      c: {
        value: 3
      },
    });

    return {
      job,
      job2
    };
  },
};
</script>
```



## readonly 与 shallowReadonly

> 性能优化，只读

```vue
<script>
import { reactive, readonly, shallowReadonly } from "@vue/runtime-core";
export default {
  name: "App",
  components: {},
  setup() {
    let job = reactive({
      a: 1,
      b: 2,
      c: {
        value: 3,
      },
    });

    let job2 = readonly(job); // 只读
    console.log('readonly', job2);

    let job3 = shallowReadonly(job); // 仅第一层只读
    console.log('shallowReadonly', job3)

    return {
      job,
      job2,
      job3
    };
  },
};
</script>
```



## toRaw 与 markRaw

> 性能优化，只处理 reactive，使其失去响应式功能

```vue
<script>
import { markRaw, reactive, toRaw } from "@vue/runtime-core";
import axios from "axios";
export default {
  name: "App",
  components: {},
  setup() {
    let job = reactive({
      a: 1,
      b: 2,
      axios: markRaw(axios), // 这里不应该是响应式的
    });

    job.c = toRaw({
      value: 3, // 不再是响应式
    });

    console.log(job);

    return {
      job,
    };
  },
};
</script>
```



## customRef

> 自定义Ref

```vue
<script>
import { customRef } from "@vue/runtime-core";
export default {
  name: "App",
  components: {},
  setup() {
    function myRef(value) {
      let timer; // 防抖
      return customRef((track, trigger) => {
        return {
          get() {
            console.log("读取时返回");
            track(); // 配置追踪返回的数据的变化
            return value;
          },
          set(newValue) {
            console.log("被修改时的操作", newValue);
            value = newValue;
            clearTimeout(timer);
            timer = setTimeout(() => {
              trigger(); // 重新解析模板
            }, 500);
          },
        };
      });
    }

    let keyword = myRef("hello");

    keyword.value = 2;
    return {};
  },
};
</script>
```



## 响应式数据的判断

```vue
<script>
import { ref, isRef, isReactive, isReadonly, isProxy } from "@vue/reactivity";
export default {
  name: "App",
  components: {},
  setup() {
    let a = ref(0);

    console.log(isRef(a));
    console.log(isReactive(a));
    console.log(isReadonly(a));
    console.log(isProxy(a));

    return {};
  },
};
</script>
```



## provide 与 inject

父传递：

```vue
<script>
import { provide, ref } from "@vue/runtime-core";
export default {
  name: "App",
  components: {},
  setup() {
    let a = ref(5);
    provide('aName', a) // 传递：别名, 数据
    return {};
  },
};
</script>
```

后代接收：

```vue
<script>
import { inject } from "@vue/runtime-core";
export default {
  name: "App",
  components: {},
  setup() {
    let a = inject('aName');
    console.log(a);
    return {};
  },
};
</script>
```



## Fragment

- vue2 中不要一个根标签
- vue3 中不需要根标签，内部将多个标签放入一个 Fragment 虚拟元素中
- 减少层级，减少内存占用



## Teleport

> 层级闪现
>
> to：选择器

```vue
<template>
  <div>
    <h5>弹窗</h5>
    <teleport to='body'>
        <div>
            请关闭
        </div>
    </teleport>
  </div>
</template>
```



## Suspense

> 异步组件在网速差的情况，会延迟加载，Suspense 解决抖动问题

```vue
<template>
  <h1>标题</h1>

  <!-- 运用了插槽 -->
  <Suspense>
    <template v-slot:fallback>
        <h5>加载中，请稍等...</h5>
    </template>
    <template v-slot:default>
      <Child />
    </template>
  </Suspense>
</template>
<script>
// 组件静态引入
import '子组件' from 'components/子组件';

// 组件异步引入
import { defineAsyncComponent } from "@vue/runtime-core";
const Child = defineAsyncComponent(() => import("./components/子组件"));

export default {
  name: "App",
  components: {},
  setup() {

    return {};
  },
};
</script>
```

